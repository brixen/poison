# Autogenerated from a Treetop grammar. Edits may be lost.


# vim: filetype=treetop

module Poison
  module Grammar
    include Treetop::Runtime

    def root
      @root ||= :poison
    end

    module Poison0
      def hh
        elements[0]
      end

      def s
        elements[1]
      end

      def end_of_file
        elements[2]
      end
    end

    module Poison1
      def node
        Syntax::Script.new s.node
      end
    end

    def _nt_poison
      start_index = index
      if node_cache[:poison].has_key?(index)
        cached = node_cache[:poison][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_hh
      s0 << r1
      if r1
        r2 = _nt_statements
        s0 << r2
        if r2
          r3 = _nt_end_of_file
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Poison0)
        r0.extend(Poison1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:poison][start_index] = r0

      r0
    end

    module Statements0
      def sep
        elements[0]
      end

      def s2
        elements[1]
      end
    end

    module Statements1
      def s1
        elements[0]
      end

    end

    module Statements2
      def node
        stmts = respond_to?(:s2) ? Array(s2.node) : []
        stmts.unshift s1.node
        Syntax::Statements.new stmts
      end
    end

    module Statements3
      def node
        Syntax::NilKind.new
      end
    end

    def _nt_statements
      start_index = index
      if node_cache[:statements].has_key?(index)
        cached = node_cache[:statements][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_stmt
      s1 << r2
      if r2
        s3, i3 = [], index
        loop do
          i4, s4 = index, []
          r5 = _nt_sep
          s4 << r5
          if r5
            r6 = _nt_stmt
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Statements0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s1 << r3
        if r3
          r8 = _nt_sep
          if r8
            r7 = r8
          else
            r7 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r7
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(Statements1)
        r1.extend(Statements2)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        if has_terminal?('', false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 0))
          r9.extend(Statements3)
          @index += 0
        else
          terminal_parse_failure('')
          r9 = nil
        end
        if r9
          r0 = r9
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:statements][start_index] = r0

      r0
    end

    module Stmt0
      def or
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Stmt1
      def and
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Stmt2
      def s
        elements[0]
      end

    end

    def _nt_stmt
      start_index = index
      if node_cache[:stmt].has_key?(index)
        cached = node_cache[:stmt][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_sets
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_or
          s4 << r5
          if r5
            r6 = _nt_sets
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Stmt0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            i7, s7 = index, []
            r8 = _nt_and
            s7 << r8
            if r8
              r9 = _nt_sets
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Stmt1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r3 = r7
            else
              @index = i3
              r3 = nil
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Stmt2)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:stmt][start_index] = r0

      r0
    end

    module Sets0
      def e
        elements[0]
      end

      def assign
        elements[1]
      end

      def s
        elements[2]
      end
    end

    module Sets1
      def node
        Syntax::Assign.new e.node, s.node
      end
    end

    module Sets2
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets3
      def node
        expr = e.node
        op = Syntax::Or.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets4
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets5
      def node
        expr = e.node
        op = Syntax::And.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets6
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets7
      def node
        expr = e.node
        op = Syntax::Pipe.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets8
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets9
      def node
        expr = e.node
        op = Syntax::Caret.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets10
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets11
      def node
        expr = e.node
        op = Syntax::Amp.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets12
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets13
      def node
        expr = e.node
        op = Syntax::Bitl.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets14
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets15
      def node
        expr = e.node
        op = Syntax::Bitr.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets16
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets17
      def node
        expr = e.node
        op = Syntax::Plus.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets18
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets19
      def node
        expr = e.node
        op = Syntax::Minus.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets20
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets21
      def node
        expr = e.node
        op = Syntax::Times.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets22
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets23
      def node
        expr = e.node
        op = Syntax::Div.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets24
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets25
      def node
        expr = e.node
        op = Syntax::Rem.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    module Sets26
      def e
        elements[0]
      end

      def o
        elements[1]
      end

      def assign
        elements[2]
      end

      def s
        elements[3]
      end
    end

    module Sets27
      def node
        expr = e.node
        op = Syntax::Pow.new expr, s.node
        Syntax::Assign.new expr, op
      end
    end

    def _nt_sets
      start_index = index
      if node_cache[:sets].has_key?(index)
        cached = node_cache[:sets][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_eqs
      s1 << r2
      if r2
        r3 = _nt_assign
        s1 << r3
        if r3
          r4 = _nt_sets
          s1 << r4
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(Sets0)
        r1.extend(Sets1)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i5, s5 = index, []
        r6 = _nt_eqs
        s5 << r6
        if r6
          r7 = _nt_or
          s5 << r7
          if r7
            r8 = _nt_assign
            s5 << r8
            if r8
              r9 = _nt_sets
              s5 << r9
            end
          end
        end
        if s5.last
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          r5.extend(Sets2)
          r5.extend(Sets3)
        else
          @index = i5
          r5 = nil
        end
        if r5
          r0 = r5
        else
          i10, s10 = index, []
          r11 = _nt_eqs
          s10 << r11
          if r11
            r12 = _nt_and
            s10 << r12
            if r12
              r13 = _nt_assign
              s10 << r13
              if r13
                r14 = _nt_sets
                s10 << r14
              end
            end
          end
          if s10.last
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            r10.extend(Sets4)
            r10.extend(Sets5)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r0 = r10
          else
            i15, s15 = index, []
            r16 = _nt_eqs
            s15 << r16
            if r16
              r17 = _nt_pipe
              s15 << r17
              if r17
                r18 = _nt_assign
                s15 << r18
                if r18
                  r19 = _nt_sets
                  s15 << r19
                end
              end
            end
            if s15.last
              r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
              r15.extend(Sets6)
              r15.extend(Sets7)
            else
              @index = i15
              r15 = nil
            end
            if r15
              r0 = r15
            else
              i20, s20 = index, []
              r21 = _nt_eqs
              s20 << r21
              if r21
                r22 = _nt_caret
                s20 << r22
                if r22
                  r23 = _nt_assign
                  s20 << r23
                  if r23
                    r24 = _nt_sets
                    s20 << r24
                  end
                end
              end
              if s20.last
                r20 = instantiate_node(SyntaxNode,input, i20...index, s20)
                r20.extend(Sets8)
                r20.extend(Sets9)
              else
                @index = i20
                r20 = nil
              end
              if r20
                r0 = r20
              else
                i25, s25 = index, []
                r26 = _nt_eqs
                s25 << r26
                if r26
                  r27 = _nt_amp
                  s25 << r27
                  if r27
                    r28 = _nt_assign
                    s25 << r28
                    if r28
                      r29 = _nt_sets
                      s25 << r29
                    end
                  end
                end
                if s25.last
                  r25 = instantiate_node(SyntaxNode,input, i25...index, s25)
                  r25.extend(Sets10)
                  r25.extend(Sets11)
                else
                  @index = i25
                  r25 = nil
                end
                if r25
                  r0 = r25
                else
                  i30, s30 = index, []
                  r31 = _nt_eqs
                  s30 << r31
                  if r31
                    r32 = _nt_bitl
                    s30 << r32
                    if r32
                      r33 = _nt_assign
                      s30 << r33
                      if r33
                        r34 = _nt_sets
                        s30 << r34
                      end
                    end
                  end
                  if s30.last
                    r30 = instantiate_node(SyntaxNode,input, i30...index, s30)
                    r30.extend(Sets12)
                    r30.extend(Sets13)
                  else
                    @index = i30
                    r30 = nil
                  end
                  if r30
                    r0 = r30
                  else
                    i35, s35 = index, []
                    r36 = _nt_eqs
                    s35 << r36
                    if r36
                      r37 = _nt_bitr
                      s35 << r37
                      if r37
                        r38 = _nt_assign
                        s35 << r38
                        if r38
                          r39 = _nt_sets
                          s35 << r39
                        end
                      end
                    end
                    if s35.last
                      r35 = instantiate_node(SyntaxNode,input, i35...index, s35)
                      r35.extend(Sets14)
                      r35.extend(Sets15)
                    else
                      @index = i35
                      r35 = nil
                    end
                    if r35
                      r0 = r35
                    else
                      i40, s40 = index, []
                      r41 = _nt_eqs
                      s40 << r41
                      if r41
                        r42 = _nt_plus
                        s40 << r42
                        if r42
                          r43 = _nt_assign
                          s40 << r43
                          if r43
                            r44 = _nt_sets
                            s40 << r44
                          end
                        end
                      end
                      if s40.last
                        r40 = instantiate_node(SyntaxNode,input, i40...index, s40)
                        r40.extend(Sets16)
                        r40.extend(Sets17)
                      else
                        @index = i40
                        r40 = nil
                      end
                      if r40
                        r0 = r40
                      else
                        i45, s45 = index, []
                        r46 = _nt_eqs
                        s45 << r46
                        if r46
                          r47 = _nt_minus
                          s45 << r47
                          if r47
                            r48 = _nt_assign
                            s45 << r48
                            if r48
                              r49 = _nt_sets
                              s45 << r49
                            end
                          end
                        end
                        if s45.last
                          r45 = instantiate_node(SyntaxNode,input, i45...index, s45)
                          r45.extend(Sets18)
                          r45.extend(Sets19)
                        else
                          @index = i45
                          r45 = nil
                        end
                        if r45
                          r0 = r45
                        else
                          i50, s50 = index, []
                          r51 = _nt_eqs
                          s50 << r51
                          if r51
                            r52 = _nt_times
                            s50 << r52
                            if r52
                              r53 = _nt_assign
                              s50 << r53
                              if r53
                                r54 = _nt_sets
                                s50 << r54
                              end
                            end
                          end
                          if s50.last
                            r50 = instantiate_node(SyntaxNode,input, i50...index, s50)
                            r50.extend(Sets20)
                            r50.extend(Sets21)
                          else
                            @index = i50
                            r50 = nil
                          end
                          if r50
                            r0 = r50
                          else
                            i55, s55 = index, []
                            r56 = _nt_eqs
                            s55 << r56
                            if r56
                              r57 = _nt_div
                              s55 << r57
                              if r57
                                r58 = _nt_assign
                                s55 << r58
                                if r58
                                  r59 = _nt_sets
                                  s55 << r59
                                end
                              end
                            end
                            if s55.last
                              r55 = instantiate_node(SyntaxNode,input, i55...index, s55)
                              r55.extend(Sets22)
                              r55.extend(Sets23)
                            else
                              @index = i55
                              r55 = nil
                            end
                            if r55
                              r0 = r55
                            else
                              i60, s60 = index, []
                              r61 = _nt_eqs
                              s60 << r61
                              if r61
                                r62 = _nt_rem
                                s60 << r62
                                if r62
                                  r63 = _nt_assign
                                  s60 << r63
                                  if r63
                                    r64 = _nt_sets
                                    s60 << r64
                                  end
                                end
                              end
                              if s60.last
                                r60 = instantiate_node(SyntaxNode,input, i60...index, s60)
                                r60.extend(Sets24)
                                r60.extend(Sets25)
                              else
                                @index = i60
                                r60 = nil
                              end
                              if r60
                                r0 = r60
                              else
                                i65, s65 = index, []
                                r66 = _nt_eqs
                                s65 << r66
                                if r66
                                  r67 = _nt_pow
                                  s65 << r67
                                  if r67
                                    r68 = _nt_assign
                                    s65 << r68
                                    if r68
                                      r69 = _nt_sets
                                      s65 << r69
                                    end
                                  end
                                end
                                if s65.last
                                  r65 = instantiate_node(SyntaxNode,input, i65...index, s65)
                                  r65.extend(Sets26)
                                  r65.extend(Sets27)
                                else
                                  @index = i65
                                  r65 = nil
                                end
                                if r65
                                  r0 = r65
                                else
                                  r70 = _nt_eqs
                                  if r70
                                    r0 = r70
                                  else
                                    @index = i0
                                    r0 = nil
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end

      node_cache[:sets][start_index] = r0

      r0
    end

    module Eqs0
      def cmp
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Eqs1
      def eq
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Eqs2
      def neq
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Eqs3
      def c
        elements[0]
      end

    end

    def _nt_eqs
      start_index = index
      if node_cache[:eqs].has_key?(index)
        cached = node_cache[:eqs][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_cmps
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_cmp
          s4 << r5
          if r5
            r6 = _nt_cmps
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Eqs0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            i7, s7 = index, []
            r8 = _nt_eq
            s7 << r8
            if r8
              r9 = _nt_cmps
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Eqs1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r3 = r7
            else
              i10, s10 = index, []
              r11 = _nt_neq
              s10 << r11
              if r11
                r12 = _nt_cmps
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(Eqs2)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r3 = r10
              else
                @index = i3
                r3 = nil
              end
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Eqs3)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:eqs][start_index] = r0

      r0
    end

    module Cmps0
      def gte
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Cmps1
      def gt
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Cmps2
      def lte
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Cmps3
      def lt
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Cmps4
      def o
        elements[0]
      end

    end

    def _nt_cmps
      start_index = index
      if node_cache[:cmps].has_key?(index)
        cached = node_cache[:cmps][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_bitors
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_gte
          s4 << r5
          if r5
            r6 = _nt_bitors
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Cmps0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            i7, s7 = index, []
            r8 = _nt_gt
            s7 << r8
            if r8
              r9 = _nt_bitors
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Cmps1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r3 = r7
            else
              i10, s10 = index, []
              r11 = _nt_lte
              s10 << r11
              if r11
                r12 = _nt_bitors
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(Cmps2)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r3 = r10
              else
                i13, s13 = index, []
                r14 = _nt_lt
                s13 << r14
                if r14
                  r15 = _nt_bitors
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(Cmps3)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r3 = r13
                else
                  @index = i3
                  r3 = nil
                end
              end
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Cmps4)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:cmps][start_index] = r0

      r0
    end

    module Bitors0
      def pipe
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Bitors1
      def caret
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Bitors2
      def a
        elements[0]
      end

    end

    def _nt_bitors
      start_index = index
      if node_cache[:bitors].has_key?(index)
        cached = node_cache[:bitors][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_bitand
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_pipe
          s4 << r5
          if r5
            r6 = _nt_bitand
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Bitors0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            i7, s7 = index, []
            r8 = _nt_caret
            s7 << r8
            if r8
              r9 = _nt_bitand
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Bitors1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r3 = r7
            else
              @index = i3
              r3 = nil
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Bitors2)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:bitors][start_index] = r0

      r0
    end

    module Bitand0
      def amp
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Bitand1
      def b
        elements[0]
      end

    end

    def _nt_bitand
      start_index = index
      if node_cache[:bitand].has_key?(index)
        cached = node_cache[:bitand][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_bitshift
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3, s3 = index, []
          r4 = _nt_amp
          s3 << r4
          if r4
            r5 = _nt_bitshift
            s3 << r5
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(Bitand0)
          else
            @index = i3
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Bitand1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:bitand][start_index] = r0

      r0
    end

    module Bitshift0
      def bitl
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Bitshift1
      def bitr
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Bitshift2
      def s
        elements[0]
      end

    end

    def _nt_bitshift
      start_index = index
      if node_cache[:bitshift].has_key?(index)
        cached = node_cache[:bitshift][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_sum
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_bitl
          s4 << r5
          if r5
            r6 = _nt_sum
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Bitshift0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            i7, s7 = index, []
            r8 = _nt_bitr
            s7 << r8
            if r8
              r9 = _nt_sum
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Bitshift1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r3 = r7
            else
              @index = i3
              r3 = nil
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Bitshift2)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:bitshift][start_index] = r0

      r0
    end

    module Sum0
      def plus
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Sum1
      def minus
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Sum2
      def p
        elements[0]
      end

    end

    def _nt_sum
      start_index = index
      if node_cache[:sum].has_key?(index)
        cached = node_cache[:sum][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_product
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_plus
          s4 << r5
          if r5
            r6 = _nt_product
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Sum0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            i7, s7 = index, []
            r8 = _nt_minus
            s7 << r8
            if r8
              r9 = _nt_product
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Sum1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r3 = r7
            else
              @index = i3
              r3 = nil
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Sum2)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:sum][start_index] = r0

      r0
    end

    module Product0
      def times
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Product1
      def div
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Product2
      def rem
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Product3
      def pow
        elements[0]
      end

      def x
        elements[1]
      end
    end

    module Product4
      def s
        elements[0]
      end

    end

    def _nt_product
      start_index = index
      if node_cache[:product].has_key?(index)
        cached = node_cache[:product][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_sign
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_times
          s4 << r5
          if r5
            r6 = _nt_sign
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Product0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            i7, s7 = index, []
            r8 = _nt_div
            s7 << r8
            if r8
              r9 = _nt_sign
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Product1)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r3 = r7
            else
              i10, s10 = index, []
              r11 = _nt_rem
              s10 << r11
              if r11
                r12 = _nt_sign
                s10 << r12
              end
              if s10.last
                r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                r10.extend(Product2)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r3 = r10
              else
                i13, s13 = index, []
                r14 = _nt_pow
                s13 << r14
                if r14
                  r15 = _nt_sign
                  s13 << r15
                end
                if s13.last
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  r13.extend(Product3)
                else
                  @index = i13
                  r13 = nil
                end
                if r13
                  r3 = r13
                else
                  @index = i3
                  r3 = nil
                end
              end
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Product4)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:product][start_index] = r0

      r0
    end

    module Sign0
      def minus
        elements[0]
      end

      def s
        elements[2]
      end
    end

    module Sign1
      def plus
        elements[0]
      end

      def s
        elements[2]
      end
    end

    module Sign2
      def not
        elements[0]
      end

      def s
        elements[1]
      end
    end

    module Sign3
      def wavy
        elements[0]
      end

      def s
        elements[1]
      end
    end

    module Sign4
      def node
        Syntax::Expression.new elements.map { |e| e.node }.flatten.compact
      end
    end

    def _nt_sign
      start_index = index
      if node_cache[:sign].has_key?(index)
        cached = node_cache[:sign][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_minus
      s1 << r2
      if r2
        i3 = index
        r4 = _nt_minus
        if r4
          r3 = nil
        else
          @index = i3
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r3
        if r3
          r5 = _nt_sign
          s1 << r5
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(Sign0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i6, s6 = index, []
        r7 = _nt_plus
        s6 << r7
        if r7
          i8 = index
          r9 = _nt_plus
          if r9
            r8 = nil
          else
            @index = i8
            r8 = instantiate_node(SyntaxNode,input, index...index)
          end
          s6 << r8
          if r8
            r10 = _nt_sign
            s6 << r10
          end
        end
        if s6.last
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          r6.extend(Sign1)
        else
          @index = i6
          r6 = nil
        end
        if r6
          r0 = r6
        else
          i11, s11 = index, []
          r12 = _nt_not
          s11 << r12
          if r12
            r13 = _nt_sign
            s11 << r13
          end
          if s11.last
            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
            r11.extend(Sign2)
          else
            @index = i11
            r11 = nil
          end
          if r11
            r0 = r11
          else
            i14, s14 = index, []
            r15 = _nt_wavy
            s14 << r15
            if r15
              r16 = _nt_sign
              s14 << r16
            end
            if s14.last
              r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
              r14.extend(Sign3)
            else
              @index = i14
              r14 = nil
            end
            if r14
              r0 = r14
            else
              r17 = _nt_expr
              r17.extend(Sign4)
              if r17
                r0 = r17
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end

      node_cache[:sign][start_index] = r0

      r0
    end

    module Expr0
      def mminus
        elements[0]
      end

      def a
        elements[1]
      end
    end

    module Expr1
      def pplus
        elements[0]
      end

      def a
        elements[1]
      end
    end

    module Expr2
      def a
        elements[0]
      end

    end

    module Expr3
    end

    def _nt_expr
      start_index = index
      if node_cache[:expr].has_key?(index)
        cached = node_cache[:expr][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      i2, s2 = index, []
      r3 = _nt_mminus
      s2 << r3
      if r3
        r4 = _nt_atom
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Expr0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r1 = r2
      else
        i5, s5 = index, []
        r6 = _nt_pplus
        s5 << r6
        if r6
          r7 = _nt_atom
          s5 << r7
        end
        if s5.last
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          r5.extend(Expr1)
        else
          @index = i5
          r5 = nil
        end
        if r5
          r1 = r5
        else
          i8, s8 = index, []
          r9 = _nt_atom
          s8 << r9
          if r9
            i11 = index
            r12 = _nt_pplus
            if r12
              r11 = r12
            else
              r13 = _nt_mminus
              if r13
                r11 = r13
              else
                @index = i11
                r11 = nil
              end
            end
            if r11
              r10 = r11
            else
              r10 = instantiate_node(SyntaxNode,input, index...index)
            end
            s8 << r10
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(Expr2)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r1 = r8
          else
            @index = i1
            r1 = nil
          end
        end
      end
      s0 << r1
      if r1
        s14, i14 = [], index
        loop do
          r15 = _nt_call
          if r15
            s14 << r15
          else
            break
          end
        end
        r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
        s0 << r14
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Expr3)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:expr][start_index] = r0

      r0
    end

    def _nt_atom
      start_index = index
      if node_cache[:atom].has_key?(index)
        cached = node_cache[:atom][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_value
      if r1
        r0 = r1
      else
        r2 = _nt_closure
        if r2
          r0 = r2
        else
          r3 = _nt_table
          if r3
            r0 = r3
          else
            r4 = _nt_call
            if r4
              r0 = r4
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end

      node_cache[:atom][start_index] = r0

      r0
    end

    module Call0
      def n
        elements[0]
      end

    end

    module Call1
      def b
        elements[1]
      end
    end

    def _nt_call
      start_index = index
      if node_cache[:call].has_key?(index)
        cached = node_cache[:call][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      i2, s2 = index, []
      r3 = _nt_name
      s2 << r3
      if r3
        i5 = index
        r6 = _nt_value
        if r6
          r5 = r6
        else
          r7 = _nt_table
          if r7
            r5 = r7
          else
            @index = i5
            r5 = nil
          end
        end
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Call0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r1 = r2
      else
        i8 = index
        r9 = _nt_value
        if r9
          r8 = r9
        else
          r10 = _nt_table
          if r10
            r8 = r10
          else
            @index = i8
            r8 = nil
          end
        end
        if r8
          r1 = r8
        else
          @index = i1
          r1 = nil
        end
      end
      s0 << r1
      if r1
        r12 = _nt_block
        if r12
          r11 = r12
        else
          r11 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r11
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Call1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:call][start_index] = r0

      r0
    end

    module Name0
      def quiz
        elements[0]
      end

    end

    module Name1
      def m
        elements[1]
      end
    end

    def _nt_name
      start_index = index
      if node_cache[:name].has_key?(index)
        cached = node_cache[:name][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_path
      if r1
        r0 = r1
      else
        i2, s2 = index, []
        r3 = _nt_quiz
        s2 << r3
        if r3
          i4 = index
          r5 = _nt_message
          if r5
            r4 = r5
          else
            r6 = _nt_path
            if r6
              r4 = r6
            else
              @index = i4
              r4 = nil
            end
          end
          s2 << r4
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(Name0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r0 = r2
        else
          i7, s7 = index, []
          i8 = index
          r9 = _nt_keyword
          if r9
            r8 = nil
          else
            @index = i8
            r8 = instantiate_node(SyntaxNode,input, index...index)
          end
          s7 << r8
          if r8
            r10 = _nt_message
            s7 << r10
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(Name1)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end
      end

      node_cache[:name][start_index] = r0

      r0
    end

    module LickItems0
      def sep
        elements[0]
      end

      def i2
        elements[1]
      end
    end

    module LickItems1
      def i1
        elements[0]
      end

    end

    def _nt_lick_items
      start_index = index
      if node_cache[:lick_items].has_key?(index)
        cached = node_cache[:lick_items][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_lick_item
      s1 << r2
      if r2
        s3, i3 = [], index
        loop do
          i4, s4 = index, []
          r5 = _nt_sep
          s4 << r5
          if r5
            r6 = _nt_lick_item
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(LickItems0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s1 << r3
        if r3
          r8 = _nt_sep
          if r8
            r7 = r8
          else
            r7 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r7
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(LickItems1)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        if has_terminal?('', false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure('')
          r9 = nil
        end
        if r9
          r0 = r9
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:lick_items][start_index] = r0

      r0
    end

    module LickItem0
      def m
        elements[0]
      end

      def t
        elements[1]
      end

      def v
        elements[2]
      end
    end

    module LickItem1
      def m
        elements[0]
      end

      def t
        elements[1]
      end
    end

    module LickItem2
      def m
        elements[0]
      end

      def v
        elements[1]
      end

      def t
        elements[2]
      end
    end

    module LickItem3
      def m
        elements[0]
      end

      def v
        elements[1]
      end
    end

    def _nt_lick_item
      start_index = index
      if node_cache[:lick_item].has_key?(index)
        cached = node_cache[:lick_item][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_message
      s1 << r2
      if r2
        r3 = _nt_table
        s1 << r3
        if r3
          r4 = _nt_loose
          s1 << r4
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(LickItem0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i5, s5 = index, []
        r6 = _nt_message
        s5 << r6
        if r6
          r7 = _nt_table
          s5 << r7
        end
        if s5.last
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          r5.extend(LickItem1)
        else
          @index = i5
          r5 = nil
        end
        if r5
          r0 = r5
        else
          i8, s8 = index, []
          r9 = _nt_message
          s8 << r9
          if r9
            r10 = _nt_loose
            s8 << r10
            if r10
              r11 = _nt_table
              s8 << r11
            end
          end
          if s8.last
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
            r8.extend(LickItem2)
          else
            @index = i8
            r8 = nil
          end
          if r8
            r0 = r8
          else
            i12, s12 = index, []
            r13 = _nt_message
            s12 << r13
            if r13
              r14 = _nt_loose
              s12 << r14
            end
            if s12.last
              r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
              r12.extend(LickItem3)
            else
              @index = i12
              r12 = nil
            end
            if r12
              r0 = r12
            else
              r15 = _nt_message
              if r15
                r0 = r15
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end

      node_cache[:lick_item][start_index] = r0

      r0
    end

    def _nt_loose
      start_index = index
      if node_cache[:loose].has_key?(index)
        cached = node_cache[:loose][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_value
      if r1
        r0 = r1
      else
        r2 = _nt_unquoted
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:loose][start_index] = r0

      r0
    end

    module Closure0
      def t
        elements[0]
      end

      def b
        elements[1]
      end
    end

    def _nt_closure
      start_index = index
      if node_cache[:closure].has_key?(index)
        cached = node_cache[:closure][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r2 = _nt_table
      if r2
        r1 = r2
      else
        r1 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r1
      if r1
        r3 = _nt_block
        s0 << r3
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Closure0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:closure][start_index] = r0

      r0
    end

    module Table0
      def table_start
        elements[0]
      end

      def s
        elements[1]
      end

      def table_end
        elements[2]
      end
    end

    def _nt_table
      start_index = index
      if node_cache[:table].has_key?(index)
        cached = node_cache[:table][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_table_start
      s0 << r1
      if r1
        r2 = _nt_statements
        s0 << r2
        if r2
          r3 = _nt_table_end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Table0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:table][start_index] = r0

      r0
    end

    module Block0
      def block_start
        elements[0]
      end

      def s
        elements[1]
      end

      def block_end
        elements[2]
      end
    end

    def _nt_block
      start_index = index
      if node_cache[:block].has_key?(index)
        cached = node_cache[:block][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_block_start
      s0 << r1
      if r1
        r2 = _nt_statements
        s0 << r2
        if r2
          r3 = _nt_block_end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Block0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:block][start_index] = r0

      r0
    end

    module Lick0
      def lick_start
        elements[0]
      end

      def i
        elements[1]
      end

      def lick_end
        elements[2]
      end
    end

    def _nt_lick
      start_index = index
      if node_cache[:lick].has_key?(index)
        cached = node_cache[:lick][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_lick_start
      s0 << r1
      if r1
        r2 = _nt_lick_items
        s0 << r2
        if r2
          r3 = _nt_lick_end
          s0 << r3
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Lick0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:lick][start_index] = r0

      r0
    end

    module Path0
      def message
        elements[1]
      end
    end

    def _nt_path
      start_index = index
      if node_cache[:path].has_key?(index)
        cached = node_cache[:path][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('/', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('/')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_message
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Path0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:path][start_index] = r0

      r0
    end

    module Message0
      def u
        elements[0]
      end

      def h
        elements[1]
      end
    end

    module Message1
      def node
        Syntax::Message.new u.text_value
      end
    end

    def _nt_message
      start_index = index
      if node_cache[:message].has_key?(index)
        cached = node_cache[:message][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      s1, i1 = [], index
      loop do
        r2 = _nt_utfw
        if r2
          s1 << r2
        else
          break
        end
      end
      if s1.empty?
        @index = i1
        r1 = nil
      else
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      end
      s0 << r1
      if r1
        r3 = _nt_h
        s0 << r3
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Message0)
        r0.extend(Message1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:message][start_index] = r0

      r0
    end

    module Value0
      def i
        elements[0]
      end

      def h
        elements[1]
      end
    end

    module Value1
      def node
        Syntax::Value.new i.node
      end
    end

    def _nt_value
      start_index = index
      if node_cache[:value].has_key?(index)
        cached = node_cache[:value][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      r2 = _nt_immed
      s1 << r2
      if r2
        r3 = _nt_h
        s1 << r3
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(Value0)
        r1.extend(Value1)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        r4 = _nt_lick
        if r4
          r0 = r4
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:value][start_index] = r0

      r0
    end

    module Immed0
      def node
        Syntax::NilKind.new
      end
    end

    module Immed1
      def node
        Syntax::Boolean.new true
      end
    end

    module Immed2
      def node
        Syntax::Boolean.new false
      end
    end

    module Immed3
      def node
        Syntax::Imaginary.new text_value
      end
    end

    module Immed4
      def node
        Syntax::Real.new text_value.to_f
      end
    end

    module Immed5
      def node
        Syntax::Integer.new Integer(text_value)
      end
    end

    module Immed6
      def node
        Syntax::Integer.new Integer(text_value)
      end
    end

    module Immed7
      def node
        Syntax::String.new text_value[1..-2]
      end
    end

    module Immed8
      def node
        Syntax::String.new text_value[1..-2]
      end
    end

    def _nt_immed
      start_index = index
      if node_cache[:immed].has_key?(index)
        cached = node_cache[:immed][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      r1 = _nt_nil
      r1.extend(Immed0)
      if r1
        r0 = r1
      else
        r2 = _nt_true
        r2.extend(Immed1)
        if r2
          r0 = r2
        else
          r3 = _nt_false
          r3.extend(Immed2)
          if r3
            r0 = r3
          else
            r4 = _nt_imag
            r4.extend(Immed3)
            if r4
              r0 = r4
            else
              r5 = _nt_real
              r5.extend(Immed4)
              if r5
                r0 = r5
              else
                r6 = _nt_hex
                r6.extend(Immed5)
                if r6
                  r0 = r6
                else
                  r7 = _nt_int
                  r7.extend(Immed6)
                  if r7
                    r0 = r7
                  else
                    r8 = _nt_str1
                    r8.extend(Immed7)
                    if r8
                      r0 = r8
                    else
                      r9 = _nt_str2
                      r9.extend(Immed8)
                      if r9
                        r0 = r9
                      else
                        @index = i0
                        r0 = nil
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end

      node_cache[:immed][start_index] = r0

      r0
    end

    module Utfw0
    end

    module Utfw1
    end

    module Utfw2
    end

    module Utfw3
    end

    def _nt_utfw
      start_index = index
      if node_cache[:utfw].has_key?(index)
        cached = node_cache[:utfw][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      if has_terminal?('\G[A-Za-z0-9_$@;`{}]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i2, s2 = index, []
        if has_terminal?('\304', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure('\304')
          r3 = nil
        end
        s2 << r3
        if r3
          if has_terminal?('\G[\\250-\\277]', true, index)
            r4 = true
            @index += 1
          else
            r4 = nil
          end
          s2 << r4
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(Utfw0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r0 = r2
        else
          i5, s5 = index, []
          if has_terminal?('\G[\\305-\\337]', true, index)
            r6 = true
            @index += 1
          else
            r6 = nil
          end
          s5 << r6
          if r6
            if has_terminal?('\G[\\200-\\277]', true, index)
              r7 = true
              @index += 1
            else
              r7 = nil
            end
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Utfw1)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r0 = r5
          else
            i8, s8 = index, []
            if has_terminal?('\G[\\340-\\357]', true, index)
              r9 = true
              @index += 1
            else
              r9 = nil
            end
            s8 << r9
            if r9
              if has_terminal?('\G[\\200-\\277]', true, index)
                r10 = true
                @index += 1
              else
                r10 = nil
              end
              s8 << r10
              if r10
                if has_terminal?('\G[\\200-\\277]', true, index)
                  r11 = true
                  @index += 1
                else
                  r11 = nil
                end
                s8 << r11
              end
            end
            if s8.last
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              r8.extend(Utfw2)
            else
              @index = i8
              r8 = nil
            end
            if r8
              r0 = r8
            else
              i12, s12 = index, []
              if has_terminal?('\G[\\360-\\364]', true, index)
                r13 = true
                @index += 1
              else
                r13 = nil
              end
              s12 << r13
              if r13
                if has_terminal?('\G[\\200-\\277]', true, index)
                  r14 = true
                  @index += 1
                else
                  r14 = nil
                end
                s12 << r14
                if r14
                  if has_terminal?('\G[\\200-\\277]', true, index)
                    r15 = true
                    @index += 1
                  else
                    r15 = nil
                  end
                  s12 << r15
                  if r15
                    if has_terminal?('\G[\\200-\\277]', true, index)
                      r16 = true
                      @index += 1
                    else
                      r16 = nil
                    end
                    s12 << r16
                  end
                end
              end
              if s12.last
                r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                r12.extend(Utfw3)
              else
                @index = i12
                r12 = nil
              end
              if r12
                r0 = r12
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end

      node_cache[:utfw][start_index] = r0

      r0
    end

    module Utf80
    end

    module Utf81
    end

    module Utf82
    end

    def _nt_utf8
      start_index = index
      if node_cache[:utf8].has_key?(index)
        cached = node_cache[:utf8][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      if has_terminal?('\G[\\t\\n\\r\\40-\\176]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i2, s2 = index, []
        if has_terminal?('\G[\\302-\\337]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        s2 << r3
        if r3
          if has_terminal?('\G[\\200-\\277]', true, index)
            r4 = true
            @index += 1
          else
            r4 = nil
          end
          s2 << r4
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(Utf80)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r0 = r2
        else
          i5, s5 = index, []
          if has_terminal?('\G[\\340-\\357]', true, index)
            r6 = true
            @index += 1
          else
            r6 = nil
          end
          s5 << r6
          if r6
            if has_terminal?('\G[\\200-\\277]', true, index)
              r7 = true
              @index += 1
            else
              r7 = nil
            end
            s5 << r7
            if r7
              if has_terminal?('\G[\\200-\\277]', true, index)
                r8 = true
                @index += 1
              else
                r8 = nil
              end
              s5 << r8
            end
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(Utf81)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r0 = r5
          else
            i9, s9 = index, []
            if has_terminal?('\G[\\360-\\364]', true, index)
              r10 = true
              @index += 1
            else
              r10 = nil
            end
            s9 << r10
            if r10
              if has_terminal?('\G[\\200-\\277]', true, index)
                r11 = true
                @index += 1
              else
                r11 = nil
              end
              s9 << r11
              if r11
                if has_terminal?('\G[\\200-\\277]', true, index)
                  r12 = true
                  @index += 1
                else
                  r12 = nil
                end
                s9 << r12
                if r12
                  if has_terminal?('\G[\\200-\\277]', true, index)
                    r13 = true
                    @index += 1
                  else
                    r13 = nil
                  end
                  s9 << r13
                end
              end
            end
            if s9.last
              r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
              r9.extend(Utf82)
            else
              @index = i9
              r9 = nil
            end
            if r9
              r0 = r9
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end

      node_cache[:utf8][start_index] = r0

      r0
    end

    def _nt_comma
      start_index = index
      if node_cache[:comma].has_key?(index)
        cached = node_cache[:comma][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?(',', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(',')
        r0 = nil
      end

      node_cache[:comma][start_index] = r0

      r0
    end

    module BlockStart0
      def hh
        elements[1]
      end
    end

    def _nt_block_start
      start_index = index
      if node_cache[:block_start].has_key?(index)
        cached = node_cache[:block_start][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(':', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(':')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(BlockStart0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:block_start][start_index] = r0

      r0
    end

    module BlockEnd0
      def h
        elements[1]
      end
    end

    def _nt_block_end
      start_index = index
      if node_cache[:block_end].has_key?(index)
        cached = node_cache[:block_end][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('.', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('.')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_h
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(BlockEnd0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:block_end][start_index] = r0

      r0
    end

    module TableStart0
      def hh
        elements[1]
      end
    end

    def _nt_table_start
      start_index = index
      if node_cache[:table_start].has_key?(index)
        cached = node_cache[:table_start][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('(', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('(')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(TableStart0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:table_start][start_index] = r0

      r0
    end

    module TableEnd0
      def h
        elements[1]
      end
    end

    def _nt_table_end
      start_index = index
      if node_cache[:table_end].has_key?(index)
        cached = node_cache[:table_end][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(')', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(')')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_h
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(TableEnd0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:table_end][start_index] = r0

      r0
    end

    module LickStart0
      def hh
        elements[1]
      end
    end

    def _nt_lick_start
      start_index = index
      if node_cache[:lick_start].has_key?(index)
        cached = node_cache[:lick_start][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('[', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('[')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(LickStart0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:lick_start][start_index] = r0

      r0
    end

    module LickEnd0
      def h
        elements[1]
      end
    end

    def _nt_lick_end
      start_index = index
      if node_cache[:lick_end].has_key?(index)
        cached = node_cache[:lick_end][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?(']', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(']')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_h
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(LickEnd0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:lick_end][start_index] = r0

      r0
    end

    module Quiz0
      def hh
        elements[1]
      end
    end

    def _nt_quiz
      start_index = index
      if node_cache[:quiz].has_key?(index)
        cached = node_cache[:quiz][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('?', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('?')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Quiz0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:quiz][start_index] = r0

      r0
    end

    module Assign0
      def hh
        elements[1]
      end
    end

    def _nt_assign
      start_index = index
      if node_cache[:assign].has_key?(index)
        cached = node_cache[:assign][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('=', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('=')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Assign0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:assign][start_index] = r0

      r0
    end

    module Pplus0
      def h
        elements[1]
      end
    end

    def _nt_pplus
      start_index = index
      if node_cache[:pplus].has_key?(index)
        cached = node_cache[:pplus][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('++', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('++')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_h
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Pplus0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:pplus][start_index] = r0

      r0
    end

    module Mminus0
      def h
        elements[1]
      end
    end

    def _nt_mminus
      start_index = index
      if node_cache[:mminus].has_key?(index)
        cached = node_cache[:mminus][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('--', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('--')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_h
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Mminus0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:mminus][start_index] = r0

      r0
    end

    module Minus0
      def hh
        elements[1]
      end
    end

    def _nt_minus
      start_index = index
      if node_cache[:minus].has_key?(index)
        cached = node_cache[:minus][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('-', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('-')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Minus0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:minus][start_index] = r0

      r0
    end

    module Plus0
      def hh
        elements[1]
      end
    end

    def _nt_plus
      start_index = index
      if node_cache[:plus].has_key?(index)
        cached = node_cache[:plus][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('+', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('+')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Plus0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:plus][start_index] = r0

      r0
    end

    module Wavy0
      def hh
        elements[1]
      end
    end

    def _nt_wavy
      start_index = index
      if node_cache[:wavy].has_key?(index)
        cached = node_cache[:wavy][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('~', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('~')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Wavy0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:wavy][start_index] = r0

      r0
    end

    module Times0
      def hh
        elements[1]
      end
    end

    def _nt_times
      start_index = index
      if node_cache[:times].has_key?(index)
        cached = node_cache[:times][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('*', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('*')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Times0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:times][start_index] = r0

      r0
    end

    module Div0
      def hh
        elements[1]
      end
    end

    def _nt_div
      start_index = index
      if node_cache[:div].has_key?(index)
        cached = node_cache[:div][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('/', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('/')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Div0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:div][start_index] = r0

      r0
    end

    module Rem0
      def hh
        elements[1]
      end
    end

    def _nt_rem
      start_index = index
      if node_cache[:rem].has_key?(index)
        cached = node_cache[:rem][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('%', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('%')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Rem0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:rem][start_index] = r0

      r0
    end

    module Pow0
      def hh
        elements[1]
      end
    end

    def _nt_pow
      start_index = index
      if node_cache[:pow].has_key?(index)
        cached = node_cache[:pow][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('**', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('**')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Pow0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:pow][start_index] = r0

      r0
    end

    module Bitl0
      def hh
        elements[1]
      end
    end

    def _nt_bitl
      start_index = index
      if node_cache[:bitl].has_key?(index)
        cached = node_cache[:bitl][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('<<', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('<<')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Bitl0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:bitl][start_index] = r0

      r0
    end

    module Bitr0
      def hh
        elements[1]
      end
    end

    def _nt_bitr
      start_index = index
      if node_cache[:bitr].has_key?(index)
        cached = node_cache[:bitr][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('>>', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('>>')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Bitr0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:bitr][start_index] = r0

      r0
    end

    module Amp0
      def hh
        elements[1]
      end
    end

    def _nt_amp
      start_index = index
      if node_cache[:amp].has_key?(index)
        cached = node_cache[:amp][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('&', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('&')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Amp0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:amp][start_index] = r0

      r0
    end

    module Caret0
      def hh
        elements[1]
      end
    end

    def _nt_caret
      start_index = index
      if node_cache[:caret].has_key?(index)
        cached = node_cache[:caret][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('^', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('^')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Caret0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:caret][start_index] = r0

      r0
    end

    module Pipe0
      def hh
        elements[1]
      end
    end

    def _nt_pipe
      start_index = index
      if node_cache[:pipe].has_key?(index)
        cached = node_cache[:pipe][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('|', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('|')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Pipe0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:pipe][start_index] = r0

      r0
    end

    module Lt0
      def hh
        elements[1]
      end
    end

    def _nt_lt
      start_index = index
      if node_cache[:lt].has_key?(index)
        cached = node_cache[:lt][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('<', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('<')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Lt0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:lt][start_index] = r0

      r0
    end

    module Lte0
      def hh
        elements[1]
      end
    end

    def _nt_lte
      start_index = index
      if node_cache[:lte].has_key?(index)
        cached = node_cache[:lte][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('<=', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('<=')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Lte0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:lte][start_index] = r0

      r0
    end

    module Gt0
      def hh
        elements[1]
      end
    end

    def _nt_gt
      start_index = index
      if node_cache[:gt].has_key?(index)
        cached = node_cache[:gt][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('>', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('>')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Gt0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:gt][start_index] = r0

      r0
    end

    module Gte0
      def hh
        elements[1]
      end
    end

    def _nt_gte
      start_index = index
      if node_cache[:gte].has_key?(index)
        cached = node_cache[:gte][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('>=', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('>=')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_hh
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Gte0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:gte][start_index] = r0

      r0
    end

    def _nt_neq
      start_index = index
      if node_cache[:neq].has_key?(index)
        cached = node_cache[:neq][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('!=', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('!=')
        r0 = nil
      end

      node_cache[:neq][start_index] = r0

      r0
    end

    def _nt_eq
      start_index = index
      if node_cache[:eq].has_key?(index)
        cached = node_cache[:eq][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('==', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('==')
        r0 = nil
      end

      node_cache[:eq][start_index] = r0

      r0
    end

    def _nt_cmp
      start_index = index
      if node_cache[:cmp].has_key?(index)
        cached = node_cache[:cmp][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('<=>', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure('<=>')
        r0 = nil
      end

      node_cache[:cmp][start_index] = r0

      r0
    end

    module And0
    end

    module And1
      def hh
        elements[1]
      end
    end

    def _nt_and
      start_index = index
      if node_cache[:and].has_key?(index)
        cached = node_cache[:and][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      if has_terminal?("&&", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("&&")
        r2 = nil
      end
      if r2
        r1 = r2
      else
        i3, s3 = index, []
        if has_terminal?("and", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
          @index += 3
        else
          terminal_parse_failure("and")
          r4 = nil
        end
        s3 << r4
        if r4
          i5 = index
          r6 = _nt_utfw
          if r6
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(And0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      s0 << r1
      if r1
        r7 = _nt_hh
        s0 << r7
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(And1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:and][start_index] = r0

      r0
    end

    module Or0
    end

    module Or1
      def hh
        elements[1]
      end
    end

    def _nt_or
      start_index = index
      if node_cache[:or].has_key?(index)
        cached = node_cache[:or][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      if has_terminal?("||", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("||")
        r2 = nil
      end
      if r2
        r1 = r2
      else
        i3, s3 = index, []
        if has_terminal?("or", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("or")
          r4 = nil
        end
        s3 << r4
        if r4
          i5 = index
          r6 = _nt_utfw
          if r6
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Or0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      s0 << r1
      if r1
        r7 = _nt_hh
        s0 << r7
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Or1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:or][start_index] = r0

      r0
    end

    module Not0
    end

    module Not1
      def hh
        elements[1]
      end
    end

    def _nt_not
      start_index = index
      if node_cache[:not].has_key?(index)
        cached = node_cache[:not][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      if has_terminal?("!", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("!")
        r2 = nil
      end
      if r2
        r1 = r2
      else
        i3, s3 = index, []
        if has_terminal?("not", false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
          @index += 3
        else
          terminal_parse_failure("not")
          r4 = nil
        end
        s3 << r4
        if r4
          i5 = index
          r6 = _nt_utfw
          if r6
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Not0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      s0 << r1
      if r1
        r7 = _nt_hh
        s0 << r7
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Not1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:not][start_index] = r0

      r0
    end

    def _nt_keyword
      start_index = index
      if node_cache[:keyword].has_key?(index)
        cached = node_cache[:keyword][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      if has_terminal?("and", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure("and")
        r1 = nil
      end
      if r1
        r0 = r1
      else
        if has_terminal?("or", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("or")
          r2 = nil
        end
        if r2
          r0 = r2
        else
          if has_terminal?("not", false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 3))
            @index += 3
          else
            terminal_parse_failure("not")
            r3 = nil
          end
          if r3
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end
      end

      node_cache[:keyword][start_index] = r0

      r0
    end

    module Nil0
    end

    def _nt_nil
      start_index = index
      if node_cache[:nil].has_key?(index)
        cached = node_cache[:nil][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("nil", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure("nil")
        r1 = nil
      end
      s0 << r1
      if r1
        i2 = index
        r3 = _nt_utfw
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Nil0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:nil][start_index] = r0

      r0
    end

    module True0
    end

    def _nt_true
      start_index = index
      if node_cache[:true].has_key?(index)
        cached = node_cache[:true][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("true", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
        @index += 4
      else
        terminal_parse_failure("true")
        r1 = nil
      end
      s0 << r1
      if r1
        i2 = index
        r3 = _nt_utfw
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(True0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:true][start_index] = r0

      r0
    end

    module False0
    end

    def _nt_false
      start_index = index
      if node_cache[:false].has_key?(index)
        cached = node_cache[:false][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("false", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure("false")
        r1 = nil
      end
      s0 << r1
      if r1
        i2 = index
        r3 = _nt_utfw
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(False0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:false][start_index] = r0

      r0
    end

    def _nt_hexl
      start_index = index
      if node_cache[:hexl].has_key?(index)
        cached = node_cache[:hexl][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('\G[0-9A-Fa-f]', true, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        r0 = nil
      end

      node_cache[:hexl][start_index] = r0

      r0
    end

    module Hex0
    end

    def _nt_hex
      start_index = index
      if node_cache[:hex].has_key?(index)
        cached = node_cache[:hex][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('0x', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure('0x')
        r1 = nil
      end
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          r3 = _nt_hexl
          if r3
            s2 << r3
          else
            break
          end
        end
        if s2.empty?
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Hex0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:hex][start_index] = r0

      r0
    end

    module Int0
    end

    def _nt_int
      start_index = index
      if node_cache[:int].has_key?(index)
        cached = node_cache[:int][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      if has_terminal?('0', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('0')
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i2, s2 = index, []
        if has_terminal?('\G[1-9]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        s2 << r3
        if r3
          s4, i4 = [], index
          loop do
            if has_terminal?('\G[0-9]', true, index)
              r5 = true
              @index += 1
            else
              r5 = nil
            end
            if r5
              s4 << r5
            else
              break
            end
          end
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          s2 << r4
        end
        if s2.last
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          r2.extend(Int0)
        else
          @index = i2
          r2 = nil
        end
        if r2
          r0 = r2
        else
          @index = i0
          r0 = nil
        end
      end

      node_cache[:int][start_index] = r0

      r0
    end

    module Real0
    end

    module Real1
      def int1
        elements[0]
      end

      def int2
        elements[2]
      end

    end

    def _nt_real
      start_index = index
      if node_cache[:real].has_key?(index)
        cached = node_cache[:real][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_int
      s0 << r1
      if r1
        if has_terminal?('.', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('.')
          r2 = nil
        end
        s0 << r2
        if r2
          r3 = _nt_int
          s0 << r3
          if r3
            i5, s5 = index, []
            if has_terminal?('e', false, index)
              r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('e')
              r6 = nil
            end
            s5 << r6
            if r6
              if has_terminal?('\G[-+]', true, index)
                r7 = true
                @index += 1
              else
                r7 = nil
              end
              s5 << r7
              if r7
                s8, i8 = [], index
                loop do
                  if has_terminal?('\G[0-9]', true, index)
                    r9 = true
                    @index += 1
                  else
                    r9 = nil
                  end
                  if r9
                    s8 << r9
                  else
                    break
                  end
                end
                if s8.empty?
                  @index = i8
                  r8 = nil
                else
                  r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
                end
                s5 << r8
              end
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(Real0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              r4 = r5
            else
              r4 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r4
          end
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Real1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:real][start_index] = r0

      r0
    end

    module Imag0
      def real
        elements[0]
      end

    end

    def _nt_imag
      start_index = index
      if node_cache[:imag].has_key?(index)
        cached = node_cache[:imag][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_real
      s0 << r1
      if r1
        if has_terminal?('i', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('i')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Imag0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:imag][start_index] = r0

      r0
    end

    def _nt_q1
      start_index = index
      if node_cache[:q1].has_key?(index)
        cached = node_cache[:q1][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('\G[\']', true, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        r0 = nil
      end

      node_cache[:q1][start_index] = r0

      r0
    end

    module C10
      def utf8
        elements[1]
      end
    end

    def _nt_c1
      start_index = index
      if node_cache[:c1].has_key?(index)
        cached = node_cache[:c1][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1, s1 = index, []
        i2 = index
        r3 = _nt_q1
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r2
        if r2
          r4 = _nt_utf8
          s1 << r4
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(C10)
        else
          @index = i1
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      end

      node_cache[:c1][start_index] = r0

      r0
    end

    module Str10
      def q11
        elements[0]
      end

      def q12
        elements[1]
      end
    end

    module Str11
      def q11
        elements[0]
      end

      def q12
        elements[2]
      end
    end

    def _nt_str1
      start_index = index
      if node_cache[:str1].has_key?(index)
        cached = node_cache[:str1][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_q1
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          i4, s4 = index, []
          r5 = _nt_q1
          s4 << r5
          if r5
            r6 = _nt_q1
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(Str10)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r3 = r4
          else
            r7 = _nt_c1
            if r7
              r3 = r7
            else
              @index = i3
              r3 = nil
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
        if r2
          r8 = _nt_q1
          s0 << r8
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Str11)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:str1][start_index] = r0

      r0
    end

    def _nt_esc
      start_index = index
      if node_cache[:esc].has_key?(index)
        cached = node_cache[:esc][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?("\\", false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("\\")
        r0 = nil
      end

      node_cache[:esc][start_index] = r0

      r0
    end

    module Escn0
      def esc
        elements[0]
      end

    end

    def _nt_escn
      start_index = index
      if node_cache[:escn].has_key?(index)
        cached = node_cache[:escn][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_esc
      s0 << r1
      if r1
        if has_terminal?('n', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('n')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Escn0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:escn][start_index] = r0

      r0
    end

    module Escb0
      def esc
        elements[0]
      end

    end

    def _nt_escb
      start_index = index
      if node_cache[:escb].has_key?(index)
        cached = node_cache[:escb][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_esc
      s0 << r1
      if r1
        if has_terminal?('b', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('b')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Escb0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:escb][start_index] = r0

      r0
    end

    module Escf0
      def esc
        elements[0]
      end

    end

    def _nt_escf
      start_index = index
      if node_cache[:escf].has_key?(index)
        cached = node_cache[:escf][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_esc
      s0 << r1
      if r1
        if has_terminal?('f', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('f')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Escf0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:escf][start_index] = r0

      r0
    end

    module Escr0
      def esc
        elements[0]
      end

    end

    def _nt_escr
      start_index = index
      if node_cache[:escr].has_key?(index)
        cached = node_cache[:escr][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_esc
      s0 << r1
      if r1
        if has_terminal?('r', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('r')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Escr0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:escr][start_index] = r0

      r0
    end

    module Esct0
      def esc
        elements[0]
      end

    end

    def _nt_esct
      start_index = index
      if node_cache[:esct].has_key?(index)
        cached = node_cache[:esct][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_esc
      s0 << r1
      if r1
        if has_terminal?('t', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('t')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Esct0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:esct][start_index] = r0

      r0
    end

    module Escu0
      def esc
        elements[0]
      end

      def u
        elements[1]
      end

      def hexl1
        elements[2]
      end

      def hexl2
        elements[3]
      end

      def hexl3
        elements[4]
      end

      def hexl4
        elements[5]
      end
    end

    def _nt_escu
      start_index = index
      if node_cache[:escu].has_key?(index)
        cached = node_cache[:escu][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_esc
      s0 << r1
      if r1
        r2 = _nt_u
        s0 << r2
        if r2
          r3 = _nt_hexl
          s0 << r3
          if r3
            r4 = _nt_hexl
            s0 << r4
            if r4
              r5 = _nt_hexl
              s0 << r5
              if r5
                r6 = _nt_hexl
                s0 << r6
              end
            end
          end
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Escu0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:escu][start_index] = r0

      r0
    end

    module Escc0
      def esc
        elements[0]
      end

      def utf8
        elements[1]
      end
    end

    def _nt_escc
      start_index = index
      if node_cache[:escc].has_key?(index)
        cached = node_cache[:escc][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_esc
      s0 << r1
      if r1
        r2 = _nt_utf8
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Escc0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:escc][start_index] = r0

      r0
    end

    def _nt_q2
      start_index = index
      if node_cache[:q2].has_key?(index)
        cached = node_cache[:q2][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('\G["]', true, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        r0 = nil
      end

      node_cache[:q2][start_index] = r0

      r0
    end

    module E20
    end

    def _nt_e2
      start_index = index
      if node_cache[:e2].has_key?(index)
        cached = node_cache[:e2][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?("\\", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("\\")
        r1 = nil
      end
      s0 << r1
      if r1
        if has_terminal?('\G["]', true, index)
          r2 = true
          @index += 1
        else
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(E20)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:e2][start_index] = r0

      r0
    end

    module C20
      def utf8
        elements[2]
      end
    end

    def _nt_c2
      start_index = index
      if node_cache[:c2].has_key?(index)
        cached = node_cache[:c2][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1, s1 = index, []
        i2 = index
        r3 = _nt_q2
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r2
        if r2
          i4 = index
          r5 = _nt_esc
          if r5
            r4 = nil
          else
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r4
          if r4
            r6 = _nt_utf8
            s1 << r6
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(C20)
        else
          @index = i1
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      end

      node_cache[:c2][start_index] = r0

      r0
    end

    module Str20
      def q21
        elements[0]
      end

      def q22
        elements[2]
      end
    end

    def _nt_str2
      start_index = index
      if node_cache[:str2].has_key?(index)
        cached = node_cache[:str2][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_q2
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3 = index
          r4 = _nt_e2
          if r4
            r3 = r4
          else
            r5 = _nt_escn
            if r5
              r3 = r5
            else
              r6 = _nt_escb
              if r6
                r3 = r6
              else
                r7 = _nt_escf
                if r7
                  r3 = r7
                else
                  r8 = _nt_escr
                  if r8
                    r3 = r8
                  else
                    r9 = _nt_esct
                    if r9
                      r3 = r9
                    else
                      r10 = _nt_escu
                      if r10
                        r3 = r10
                      else
                        r11 = _nt_escc
                        if r11
                          r3 = r11
                        else
                          r12 = _nt_c2
                          if r12
                            r3 = r12
                          else
                            @index = i3
                            r3 = nil
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
        if r2
          r13 = _nt_q2
          s0 << r13
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Str20)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:str2][start_index] = r0

      r0
    end

    module UnqChar0
    end

    module UnqChar1
    end

    module UnqChar2
    end

    module UnqChar3
      def utf8
        elements[6]
      end
    end

    def _nt_unq_char
      start_index = index
      if node_cache[:unq_char].has_key?(index)
        cached = node_cache[:unq_char][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      i1, s1 = index, []
      if has_terminal?('{', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('{')
        r2 = nil
      end
      s1 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_unq_char
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        s1 << r3
        if r3
          if has_terminal?('}', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('}')
            r5 = nil
          end
          s1 << r5
        end
      end
      if s1.last
        r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
        r1.extend(UnqChar0)
      else
        @index = i1
        r1 = nil
      end
      if r1
        r0 = r1
      else
        i6, s6 = index, []
        if has_terminal?('[', false, index)
          r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[')
          r7 = nil
        end
        s6 << r7
        if r7
          s8, i8 = [], index
          loop do
            r9 = _nt_unq_char
            if r9
              s8 << r9
            else
              break
            end
          end
          if s8.empty?
            @index = i8
            r8 = nil
          else
            r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          end
          s6 << r8
          if r8
            if has_terminal?(']', false, index)
              r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(']')
              r10 = nil
            end
            s6 << r10
          end
        end
        if s6.last
          r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
          r6.extend(UnqChar1)
        else
          @index = i6
          r6 = nil
        end
        if r6
          r0 = r6
        else
          i11, s11 = index, []
          if has_terminal?('(', false, index)
            r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('(')
            r12 = nil
          end
          s11 << r12
          if r12
            s13, i13 = [], index
            loop do
              r14 = _nt_unq_char
              if r14
                s13 << r14
              else
                break
              end
            end
            if s13.empty?
              @index = i13
              r13 = nil
            else
              r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
            end
            s11 << r13
            if r13
              if has_terminal?(')', false, index)
                r15 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure(')')
                r15 = nil
              end
              s11 << r15
            end
          end
          if s11.last
            r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
            r11.extend(UnqChar2)
          else
            @index = i11
            r11 = nil
          end
          if r11
            r0 = r11
          else
            i16, s16 = index, []
            i17 = index
            if has_terminal?('{', false, index)
              r18 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('{')
              r18 = nil
            end
            if r18
              r17 = nil
            else
              @index = i17
              r17 = instantiate_node(SyntaxNode,input, index...index)
            end
            s16 << r17
            if r17
              i19 = index
              if has_terminal?('[', false, index)
                r20 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure('[')
                r20 = nil
              end
              if r20
                r19 = nil
              else
                @index = i19
                r19 = instantiate_node(SyntaxNode,input, index...index)
              end
              s16 << r19
              if r19
                i21 = index
                if has_terminal?('(', false, index)
                  r22 = instantiate_node(SyntaxNode,input, index...(index + 1))
                  @index += 1
                else
                  terminal_parse_failure('(')
                  r22 = nil
                end
                if r22
                  r21 = nil
                else
                  @index = i21
                  r21 = instantiate_node(SyntaxNode,input, index...index)
                end
                s16 << r21
                if r21
                  i23 = index
                  if has_terminal?('}', false, index)
                    r24 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('}')
                    r24 = nil
                  end
                  if r24
                    r23 = nil
                  else
                    @index = i23
                    r23 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s16 << r23
                  if r23
                    i25 = index
                    if has_terminal?(']', false, index)
                      r26 = instantiate_node(SyntaxNode,input, index...(index + 1))
                      @index += 1
                    else
                      terminal_parse_failure(']')
                      r26 = nil
                    end
                    if r26
                      r25 = nil
                    else
                      @index = i25
                      r25 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s16 << r25
                    if r25
                      i27 = index
                      if has_terminal?(')', false, index)
                        r28 = instantiate_node(SyntaxNode,input, index...(index + 1))
                        @index += 1
                      else
                        terminal_parse_failure(')')
                        r28 = nil
                      end
                      if r28
                        r27 = nil
                      else
                        @index = i27
                        r27 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s16 << r27
                      if r27
                        r29 = _nt_utf8
                        s16 << r29
                      end
                    end
                  end
                end
              end
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(UnqChar3)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r0 = r16
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end

      node_cache[:unq_char][start_index] = r0

      r0
    end

    module UnqSep0
      def sep
        elements[0]
      end

    end

    def _nt_unq_sep
      start_index = index
      if node_cache[:unq_sep].has_key?(index)
        cached = node_cache[:unq_sep][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_sep
      s0 << r1
      if r1
        i2 = index
        if has_terminal?('{', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('{')
          r3 = nil
        end
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r2
        if r2
          i4 = index
          if has_terminal?('[', false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('[')
            r5 = nil
          end
          if r5
            r4 = nil
          else
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
          if r4
            i6 = index
            if has_terminal?('(', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('(')
              r7 = nil
            end
            if r7
              r6 = nil
            else
              @index = i6
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r6
          end
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(UnqSep0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:unq_sep][start_index] = r0

      r0
    end

    module Unquoted0
      def unq_char
        elements[2]
      end
    end

    def _nt_unquoted
      start_index = index
      if node_cache[:unquoted].has_key?(index)
        cached = node_cache[:unquoted][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1, s1 = index, []
        i2 = index
        r3 = _nt_unq_sep
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r2
        if r2
          i4 = index
          r5 = _nt_lick_end
          if r5
            r4 = nil
          else
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r4
          if r4
            r6 = _nt_unq_char
            s1 << r6
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Unquoted0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      end

      node_cache[:unquoted][start_index] = r0

      r0
    end

    def _nt_h
      start_index = index
      if node_cache[:h].has_key?(index)
        cached = node_cache[:h][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1 = index
        r2 = _nt_space
        if r2
          r1 = r2
        else
          r3 = _nt_comment
          if r3
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

      node_cache[:h][start_index] = r0

      r0
    end

    def _nt_hh
      start_index = index
      if node_cache[:hh].has_key?(index)
        cached = node_cache[:hh][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1 = index
        r2 = _nt_space
        if r2
          r1 = r2
        else
          r3 = _nt_comment
          if r3
            r1 = r3
          else
            r4 = _nt_end_of_line
            if r4
              r1 = r4
            else
              @index = i1
              r1 = nil
            end
          end
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

      node_cache[:hh][start_index] = r0

      r0
    end

    module Sep0
    end

    def _nt_sep
      start_index = index
      if node_cache[:sep].has_key?(index)
        cached = node_cache[:sep][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      r2 = _nt_end_of_line
      if r2
        r1 = r2
      else
        r3 = _nt_comma
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      s0 << r1
      if r1
        s4, i4 = [], index
        loop do
          i5 = index
          r6 = _nt_space
          if r6
            r5 = r6
          else
            r7 = _nt_comment
            if r7
              r5 = r7
            else
              r8 = _nt_end_of_line
              if r8
                r5 = r8
              else
                r9 = _nt_comma
                if r9
                  r5 = r9
                else
                  @index = i5
                  r5 = nil
                end
              end
            end
          end
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s0 << r4
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Sep0)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:sep][start_index] = r0

      r0
    end

    module Comment0
      def utf8
        elements[1]
      end
    end

    module Comment1
    end

    def _nt_comment
      start_index = index
      if node_cache[:comment].has_key?(index)
        cached = node_cache[:comment][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('#', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('#')
        r1 = nil
      end
      s0 << r1
      if r1
        s2, i2 = [], index
        loop do
          i3, s3 = index, []
          i4 = index
          r5 = _nt_end_of_line
          if r5
            r4 = nil
          else
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s3 << r4
          if r4
            r6 = _nt_utf8
            s3 << r6
          end
          if s3.last
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            r3.extend(Comment0)
          else
            @index = i3
            r3 = nil
          end
          if r3
            s2 << r3
          else
            break
          end
        end
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Comment1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:comment][start_index] = r0

      r0
    end

    def _nt_space
      start_index = index
      if node_cache[:space].has_key?(index)
        cached = node_cache[:space][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      if has_terminal?(' ', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure(' ')
        r1 = nil
      end
      if r1
        r0 = r1
      else
        if has_terminal?("\f", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("\f")
          r2 = nil
        end
        if r2
          r0 = r2
        else
          if has_terminal?("\v", false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("\v")
            r3 = nil
          end
          if r3
            r0 = r3
          else
            if has_terminal?("\t", false, index)
              r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure("\t")
              r4 = nil
            end
            if r4
              r0 = r4
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end

      node_cache[:space][start_index] = r0

      r0
    end

    def _nt_end_of_line
      start_index = index
      if node_cache[:end_of_line].has_key?(index)
        cached = node_cache[:end_of_line][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      if has_terminal?("\r\n", false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("\r\n")
        r1 = nil
      end
      if r1
        r0 = r1
      else
        if has_terminal?("\n", false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("\n")
          r2 = nil
        end
        if r2
          r0 = r2
        else
          if has_terminal?("\r", false, index)
            r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("\r")
            r3 = nil
          end
          if r3
            r0 = r3
          else
            @index = i0
            r0 = nil
          end
        end
      end

      node_cache[:end_of_line][start_index] = r0

      r0
    end

    def _nt_end_of_file
      start_index = index
      if node_cache[:end_of_file].has_key?(index)
        cached = node_cache[:end_of_file][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0 = index
      if index < input_length
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("any character")
        r1 = nil
      end
      if r1
        r0 = nil
      else
        @index = i0
        r0 = instantiate_node(SyntaxNode,input, index...index)
      end

      node_cache[:end_of_file][start_index] = r0

      r0
    end

  end

  class GrammarParser < Treetop::Runtime::CompiledParser
    include Grammar
  end

end
